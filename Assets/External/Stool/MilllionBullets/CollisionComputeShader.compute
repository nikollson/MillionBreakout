#pragma kernel CheckBoxCollision

#define THREADS 32

struct State
{
	float3 Pos;
	float3 Velocity;
	float Radius;
	int Enable;
	int IsDead;
};
RWStructuredBuffer<State> States;

float3 BoxCenter;
float BoxAngle;
float BoxWidth;
float BoxHeight;

[numthreads(THREADS, 1, 1)]
void CheckBoxCollision(int3 id : SV_DispatchThreadID)
{
	if (States[id.x].Enable == 0)return;

	float c = cos(BoxAngle);
	float s = sin(BoxAngle);

	float3 local = States[id.x].Pos - BoxCenter;
	float x = c * local.x + s * local.y;
	float y = -s * local.x + c * local.y;

	float xdistRaw = abs(x) - BoxWidth / 2;
	float ydistRaw = abs(y) - BoxHeight / 2;

	float xdist = max(0, xdistRaw);
	float ydist = max(0, ydistRaw);
	float radius = States[id.x].Radius;

	if (xdist * xdist + ydist*ydist < radius * radius)
	{
		float3 localDir = float3(xdist * sign(x), ydist * sign(y), 0);
		if (xdist == 0 && ydist == 0)
		{
			localDir = float3(sign(x), 0, 0);
			if (ydistRaw > xdistRaw) localDir = float3(0, sign(y), 0);
		}
		localDir /= length(localDir);

		float rx = c * localDir.x - s * localDir.y;
		float ry = s * localDir.x + c * localDir.y;
		float3 reflecDir = float3(rx, ry, 0);

		float d = min(0, dot(States[id.x].Velocity, reflecDir));
		States[id.x].Velocity += reflecDir * d * -2;
		States[id.x].Pos += reflecDir * min(max(ydistRaw, xdistRaw) - radius, 0) * -1;
	}
}

